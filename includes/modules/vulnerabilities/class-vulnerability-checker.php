<?php
/**
 * SpamGuard Vulnerability Checker - COMPLETAMENTE IMPLEMENTADO
 * Integración completa con API de Vulnerabilidades
 *
 * @package SpamGuard
 * @version 3.0.0
 */

if (!defined('ABSPATH')) {
    exit;
}

class SpamGuard_Vulnerability_Checker {

    private static $instance = null;
    private $api_client;

    /**
     * Get singleton instance
     */
    public static function get_instance() {
        if (null === self::$instance) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * Constructor
     */
    private function __construct() {
        $this->api_client = SpamGuard_API_Client::get_instance();

        // AJAX actions para el dashboard
        add_action('wp_ajax_spamguard_scan_vulnerabilities', array($this, 'ajax_scan_vulnerabilities'));
        add_action('wp_ajax_spamguard_get_vulnerability_details', array($this, 'ajax_get_vulnerability_details'));

        // Cron para escaneo automático (semanal)
        if (!wp_next_scheduled('spamguard_weekly_vulnerability_scan')) {
            wp_schedule_event(time(), 'weekly', 'spamguard_weekly_vulnerability_scan');
        }

        add_action('spamguard_weekly_vulnerability_scan', array($this, 'scan_all'));
    }

    /**
     * ✅ Escanear todos los componentes instalados
     */
    public function scan_all() {
        // 1. Obtener componentes instalados
        $components = $this->get_installed_components();

        if (empty($components)) {
            return array(
                'success' => false,
                'message' => __('No components found to scan', 'spamguard'),
                'total_checked' => 0,
                'vulnerable_count' => 0
            );
        }

        // 2. Llamar a la API
        $result = $this->api_client->check_vulnerabilities($components);

        if (is_wp_error($result)) {
            return array(
                'success' => false,
                'message' => $result->get_error_message(),
                'total_checked' => count($components),
                'vulnerable_count' => 0
            );
        }

        // 3. Guardar resultados en la BD local
        if (isset($result['vulnerable_components']) && !empty($result['vulnerable_components'])) {
            $this->save_vulnerabilities($result['vulnerable_components']);
        }

        // 4. Actualizar marca de tiempo
        update_option('spamguard_last_vulnerability_scan', current_time('mysql'));

        // 5. Notificar si hay vulnerabilidades críticas
        if ($result['vulnerable_count'] > 0) {
            $this->maybe_send_notification($result);
        }

        return array(
            'success' => true,
            'total_checked' => $result['total_checked'],
            'vulnerable_count' => $result['vulnerable_count'],
            'vulnerable_components' => $result['vulnerable_components'],
            'message' => sprintf(
                __('Scan completed. Found %d vulnerable components out of %d checked.', 'spamguard'),
                $result['vulnerable_count'],
                $result['total_checked']
            )
        );
    }

    /**
     * ✅ Obtener todos los componentes instalados (core, plugins, themes)
     */
    private function get_installed_components() {
        $components = array();

        // 1. WordPress Core
        $wp_version = get_bloginfo('version');
        $components[] = array(
            'type' => 'core',
            'slug' => 'wordpress',
            'version' => $wp_version,
            'name' => 'WordPress Core'
        );

        // 2. Plugins activos
        if (!function_exists('get_plugins')) {
            require_once ABSPATH . 'wp-admin/includes/plugin.php';
        }

        $all_plugins = get_plugins();
        $active_plugins = get_option('active_plugins', array());

        foreach ($active_plugins as $plugin_file) {
            if (isset($all_plugins[$plugin_file])) {
                $plugin_data = $all_plugins[$plugin_file];
                $plugin_slug = dirname($plugin_file);

                // Si el plugin está en la raíz (single file), usar el nombre del archivo
                if ($plugin_slug === '.') {
                    $plugin_slug = basename($plugin_file, '.php');
                }

                $components[] = array(
                    'type' => 'plugin',
                    'slug' => $plugin_slug,
                    'version' => $plugin_data['Version'],
                    'name' => $plugin_data['Name']
                );
            }
        }

        // 3. Themes instalados
        $themes = wp_get_themes();

        foreach ($themes as $theme_slug => $theme) {
            $components[] = array(
                'type' => 'theme',
                'slug' => $theme_slug,
                'version' => $theme->get('Version'),
                'name' => $theme->get('Name')
            );
        }

        return $components;
    }

    /**
     * ✅ Guardar vulnerabilidades en BD local
     */
    private function save_vulnerabilities($vulnerable_components) {
        global $wpdb;
        $table = $wpdb->prefix . 'spamguard_vulnerabilities';

        // Limpiar vulnerabilidades antiguas
        $wpdb->query("DELETE FROM $table WHERE detected_at < DATE_SUB(NOW(), INTERVAL 30 DAY)");

        foreach ($vulnerable_components as $component) {
            if (empty($component['vulnerabilities'])) {
                continue;
            }

            foreach ($component['vulnerabilities'] as $vuln) {
                // Verificar si ya existe
                $exists = $wpdb->get_var($wpdb->prepare(
                    "SELECT id FROM $table WHERE component_slug = %s AND cve_id = %s",
                    $component['slug'],
                    isset($vuln['cve_id']) ? $vuln['cve_id'] : ''
                ));

                if ($exists) {
                    continue; // Ya está guardada
                }

                // Insertar nueva vulnerabilidad
                $wpdb->insert($table, array(
                    'component_type' => $component['type'],
                    'component_slug' => $component['slug'],
                    'component_version' => $component['version'],
                    'cve_id' => isset($vuln['cve_id']) ? $vuln['cve_id'] : null,
                    'severity' => isset($vuln['severity']) ? $vuln['severity'] : 'medium',
                    'title' => isset($vuln['title']) ? $vuln['title'] : 'Security Vulnerability',
                    'description' => isset($vuln['description']) ? $vuln['description'] : '',
                    'vuln_type' => isset($vuln['vuln_type']) ? $vuln['vuln_type'] : 'unknown',
                    'patched_in' => isset($vuln['patched_in']) ? $vuln['patched_in'] : null,
                    'reference_urls' => isset($vuln['references']) ? json_encode($vuln['references']) : null,
                    'detected_at' => current_time('mysql')
                ));
            }
        }
    }

    /**
     * ✅ Enviar notificación si hay vulnerabilidades críticas
     */
    private function maybe_send_notification($scan_result) {
        if (!get_option('spamguard_email_notifications', true)) {
            return;
        }

        // Contar vulnerabilidades críticas
        $critical_count = 0;
        $high_count = 0;

        foreach ($scan_result['vulnerable_components'] as $component) {
            if (isset($component['vulnerabilities'])) {
                foreach ($component['vulnerabilities'] as $vuln) {
                    if (isset($vuln['severity'])) {
                        if ($vuln['severity'] === 'critical') {
                            $critical_count++;
                        } elseif ($vuln['severity'] === 'high') {
                            $high_count++;
                        }
                    }
                }
            }
        }

        // Solo enviar si hay críticas o muchas high
        if ($critical_count === 0 && $high_count < 3) {
            return;
        }

        $to = get_option('spamguard_notification_email', get_option('admin_email'));
        $subject = sprintf(
            __('[SpamGuard] %d security vulnerabilities detected', 'spamguard'),
            $scan_result['vulnerable_count']
        );

        $message = sprintf(
            __('SpamGuard detected %d security vulnerabilities on your WordPress site:', 'spamguard') . "\n\n",
            $scan_result['vulnerable_count']
        );

        $message .= sprintf(__('- Critical: %d', 'spamguard') . "\n", $critical_count);
        $message .= sprintf(__('- High: %d', 'spamguard') . "\n\n", $high_count);

        $message .= __('Please review and update the affected components:', 'spamguard') . "\n";
        $message .= admin_url('admin.php?page=spamguard-vulnerabilities') . "\n\n";

        $message .= __('Affected components:', 'spamguard') . "\n";
        foreach (array_slice($scan_result['vulnerable_components'], 0, 5) as $comp) {
            $message .= sprintf("- %s (%s v%s)\n", $comp['name'], $comp['type'], $comp['version']);
        }

        wp_mail($to, $subject, $message);
    }

    /**
     * ✅ Obtener vulnerabilidades guardadas
     */
    public function get_vulnerabilities($filters = array()) {
        global $wpdb;
        $table = $wpdb->prefix . 'spamguard_vulnerabilities';

        $where = array('1=1');

        if (isset($filters['severity'])) {
            $where[] = $wpdb->prepare('severity = %s', $filters['severity']);
        }

        if (isset($filters['component_type'])) {
            $where[] = $wpdb->prepare('component_type = %s', $filters['component_type']);
        }

        $query = "SELECT * FROM $table WHERE " . implode(' AND ', $where) . " ORDER BY detected_at DESC LIMIT 100";

        return $wpdb->get_results($query);
    }

    /**
     * ✅ Obtener estadísticas
     */
    public function get_stats() {
        global $wpdb;
        $table = $wpdb->prefix . 'spamguard_vulnerabilities';

        $total = $wpdb->get_var("SELECT COUNT(*) FROM $table");

        $by_severity = array(
            'critical' => intval($wpdb->get_var("SELECT COUNT(*) FROM $table WHERE severity = 'critical'")),
            'high' => intval($wpdb->get_var("SELECT COUNT(*) FROM $table WHERE severity = 'high'")),
            'medium' => intval($wpdb->get_var("SELECT COUNT(*) FROM $table WHERE severity = 'medium'")),
            'low' => intval($wpdb->get_var("SELECT COUNT(*) FROM $table WHERE severity = 'low'"))
        );

        $by_type = array(
            'plugin' => intval($wpdb->get_var("SELECT COUNT(DISTINCT component_slug) FROM $table WHERE component_type = 'plugin'")),
            'theme' => intval($wpdb->get_var("SELECT COUNT(DISTINCT component_slug) FROM $table WHERE component_type = 'theme'")),
            'core' => intval($wpdb->get_var("SELECT COUNT(DISTINCT component_slug) FROM $table WHERE component_type = 'core'"))
        );

        return array(
            'total' => intval($total),
            'by_severity' => $by_severity,
            'by_type' => $by_type,
            'last_scan' => get_option('spamguard_last_vulnerability_scan')
        );
    }

    /**
     * ✅ Obtener detalles de una vulnerabilidad específica
     */
    public function get_vulnerability_details($vuln_id) {
        global $wpdb;
        $table = $wpdb->prefix . 'spamguard_vulnerabilities';

        return $wpdb->get_row($wpdb->prepare(
            "SELECT * FROM $table WHERE id = %d",
            $vuln_id
        ));
    }

    /**
     * ✅ AJAX: Escanear vulnerabilidades
     */
    public function ajax_scan_vulnerabilities() {
        check_ajax_referer('spamguard_ajax', 'nonce');

        if (!current_user_can('manage_options')) {
            wp_send_json_error(array('message' => __('Permission denied', 'spamguard')));
        }

        $result = $this->scan_all();

        if ($result['success']) {
            wp_send_json_success($result);
        } else {
            wp_send_json_error($result);
        }
    }

    /**
     * ✅ AJAX: Obtener detalles de vulnerabilidad
     */
    public function ajax_get_vulnerability_details() {
        check_ajax_referer('spamguard_ajax', 'nonce');

        if (!current_user_can('manage_options')) {
            wp_send_json_error(array('message' => __('Permission denied', 'spamguard')));
        }

        $vuln_id = isset($_POST['vuln_id']) ? intval($_POST['vuln_id']) : 0;

        if (!$vuln_id) {
            wp_send_json_error(array('message' => __('Invalid vulnerability ID', 'spamguard')));
        }

        $details = $this->get_vulnerability_details($vuln_id);

        if ($details) {
            wp_send_json_success(array('vulnerability' => $details));
        } else {
            wp_send_json_error(array('message' => __('Vulnerability not found', 'spamguard')));
        }
    }

    /**
     * ✅ Verificar si un componente específico tiene vulnerabilidades
     */
    public function check_component($type, $slug, $version) {
        $components = array(
            array(
                'type' => $type,
                'slug' => $slug,
                'version' => $version
            )
        );

        $result = $this->api_client->check_vulnerabilities($components);

        if (is_wp_error($result)) {
            return array(
                'has_vulnerabilities' => false,
                'error' => $result->get_error_message()
            );
        }

        return array(
            'has_vulnerabilities' => $result['vulnerable_count'] > 0,
            'vulnerabilities' => isset($result['vulnerable_components'][0]['vulnerabilities'])
                ? $result['vulnerable_components'][0]['vulnerabilities']
                : array()
        );
    }
}
